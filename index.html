<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Airflow Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .control-panel {
            width: 320px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #333;
            backdrop-filter: blur(10px);
        }

        .main-canvas {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #0a0a1a, #000);
        }

        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        label {
            font-size: 12px;
            color: #ccc;
            min-width: 120px;
        }

        input[type="range"] {
            flex: 1;
            margin: 0 10px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }

        select {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }

        .value-display {
            min-width: 40px;
            text-align: right;
            font-size: 11px;
            color: #4fc3f7;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: linear-gradient(135deg, #29b6f6, #0288d1);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .preset-buttons button {
            font-size: 10px;
            padding: 8px;
        }

        .stats-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            color: #4fc3f7;
            backdrop-filter: blur(10px);
        }

        .color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #4fc3f7;
        }

        .image-preview {
            width: 100%;
            max-height: 150px;
            object-fit: contain;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="control-group">
                <h3>üñºÔ∏è Image Controls</h3>
                <input type="file" id="imageUpload" accept="image/*">
                <img id="imagePreview" class="image-preview" style="display: none;">
                <div class="control-row">
                    <label>Image Opacity:</label>
                    <input type="range" id="imageOpacity" min="0" max="100" value="50">
                    <span class="value-display" id="imageOpacityValue">50%</span>
                </div>
                <div class="control-row">
                    <label>Image Scale:</label>
                    <input type="range" id="imageScale" min="10" max="200" value="100">
                    <span class="value-display" id="imageScaleValue">100%</span>
                </div>
            </div>

            <div class="control-group">
                <h3>üå™Ô∏è Flow Parameters</h3>
                <div class="control-row">
                    <label>Flow Strength:</label>
                    <input type="range" id="flowStrength" min="0" max="100" value="50">
                    <span class="value-display" id="flowStrengthValue">50</span>
                </div>
                <div class="control-row">
                    <label>Turbulence:</label>
                    <input type="range" id="turbulence" min="0" max="100" value="30">
                    <span class="value-display" id="turbulenceValue">30</span>
                </div>
                <div class="control-row">
                    <label>Viscosity:</label>
                    <input type="range" id="viscosity" min="0" max="100" value="20">
                    <span class="value-display" id="viscosityValue">20</span>
                </div>
                <div class="control-row">
                    <label>Flow Direction:</label>
                    <input type="range" id="flowDirection" min="0" max="360" value="0">
                    <span class="value-display" id="flowDirectionValue">0¬∞</span>
                </div>
            </div>

            <div class="control-group">
                <h3>üé® Particle System</h3>
                <div class="control-row">
                    <label>Particle Count:</label>
                    <input type="range" id="particleCount" min="100" max="5000" value="2000">
                    <span class="value-display" id="particleCountValue">2000</span>
                </div>
                <div class="control-row">
                    <label>Particle Size:</label>
                    <input type="range" id="particleSize" min="1" max="10" value="2">
                    <span class="value-display" id="particleSizeValue">2</span>
                </div>
                <div class="control-row">
                    <label>Particle Speed:</label>
                    <input type="range" id="particleSpeed" min="1" max="50" value="10">
                    <span class="value-display" id="particleSpeedValue">10</span>
                </div>
                <div class="control-row">
                    <label>Trail Length:</label>
                    <input type="range" id="trailLength" min="1" max="20" value="8">
                    <span class="value-display" id="trailLengthValue">8</span>
                </div>
                <div class="control-row">
                    <label>Particle Color:</label>
                    <input type="color" id="particleColor" value="#4fc3f7" class="color-picker">
                </div>
            </div>

            <div class="control-group">
                <h3>üåä Vector Field</h3>
                <div class="control-row">
                    <label>Show Vectors:</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="showVectors" checked>
                    </div>
                </div>
                <div class="control-row">
                    <label>Vector Density:</label>
                    <input type="range" id="vectorDensity" min="10" max="100" value="30">
                    <span class="value-display" id="vectorDensityValue">30</span>
                </div>
                <div class="control-row">
                    <label>Vector Scale:</label>
                    <input type="range" id="vectorScale" min="1" max="50" value="15">
                    <span class="value-display" id="vectorScaleValue">15</span>
                </div>
                <div class="control-row">
                    <label>Vector Color:</label>
                    <input type="color" id="vectorColor" value="#ffffff" class="color-picker">
                </div>
            </div>

            <div class="control-group">
                <h3>üîÑ Animation</h3>
                <div class="control-row">
                    <label>Animation Speed:</label>
                    <input type="range" id="animationSpeed" min="1" max="100" value="30">
                    <span class="value-display" id="animationSpeedValue">30</span>
                </div>
                <div class="control-row">
                    <label>Time Scale:</label>
                    <input type="range" id="timeScale" min="1" max="50" value="10">
                    <span class="value-display" id="timeScaleValue">10</span>
                </div>
                <div class="control-row">
                    <label>Flow Pattern:</label>
                    <select id="flowPattern">
                        <option value="uniform">Uniform Flow</option>
                        <option value="vortex">Vortex</option>
                        <option value="radial">Radial Flow</option>
                        <option value="spiral">Spiral</option>
                        <option value="wave">Wave Pattern</option>
                        <option value="turbulent">Turbulent</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <h3>üéØ Presets</h3>
                <div class="preset-buttons">
                    <button onclick="loadPreset('wind')">Wind Tunnel</button>
                    <button onclick="loadPreset('hurricane')">Hurricane</button>
                    <button onclick="loadPreset('laminar')">Laminar Flow</button>
                    <button onclick="loadPreset('chaos')">Chaos</button>
                    <button onclick="loadPreset('gentle')">Gentle Breeze</button>
                    <button onclick="loadPreset('industrial')">Industrial</button>
                </div>
            </div>

            <div class="button-group">
                <button onclick="toggleAnimation()">‚èØÔ∏è Play/Pause</button>
                <button onclick="resetSimulation()">üîÑ Reset</button>
                <button onclick="exportFrame()">üì∏ Export</button>
            </div>
        </div>

        <div class="main-canvas">
            <canvas id="airflowCanvas"></canvas>
            <div class="stats-display" id="statsDisplay">
                FPS: <span id="fpsCounter">0</span><br>
                Particles: <span id="particleCounter">0</span><br>
                Flow Rate: <span id="flowRate">0</span> m/s
            </div>
        </div>
    </div>

    <script>
        class AirflowVisualizer {
            constructor() {
                this.canvas = document.getElementById('airflowCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.vectors = [];
                this.isAnimating = true;
                this.time = 0;
                this.lastFrameTime = 0;
                this.fps = 0;
                this.uploadedImage = null;
                
                this.settings = {
                    flowStrength: 50,
                    turbulence: 30,
                    viscosity: 20,
                    flowDirection: 0,
                    particleCount: 2000,
                    particleSize: 2,
                    particleSpeed: 10,
                    trailLength: 8,
                    particleColor: '#4fc3f7',
                    showVectors: true,
                    vectorDensity: 30,
                    vectorScale: 15,
                    vectorColor: '#ffffff',
                    animationSpeed: 30,
                    timeScale: 10,
                    flowPattern: 'uniform',
                    imageOpacity: 50,
                    imageScale: 100
                };

                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.initializeParticles();
                this.generateVectorField();
                this.animate();
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Control panel listeners
                document.getElementById('imageUpload').addEventListener('change', (e) => this.handleImageUpload(e));
                
                // Slider listeners
                const sliders = [
                    'flowStrength', 'turbulence', 'viscosity', 'flowDirection',
                    'particleCount', 'particleSize', 'particleSpeed', 'trailLength',
                    'vectorDensity', 'vectorScale', 'animationSpeed', 'timeScale',
                    'imageOpacity', 'imageScale'
                ];
                
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(id + 'Value');
                    slider.addEventListener('input', (e) => {
                        this.settings[id] = parseInt(e.target.value);
                        display.textContent = id === 'flowDirection' ? e.target.value + '¬∞' : 
                                            id.includes('Opacity') || id.includes('Scale') ? e.target.value + '%' : 
                                            e.target.value;
                        this.updateSimulation();
                    });
                });

                // Color pickers
                document.getElementById('particleColor').addEventListener('change', (e) => {
                    this.settings.particleColor = e.target.value;
                });
                
                document.getElementById('vectorColor').addEventListener('change', (e) => {
                    this.settings.vectorColor = e.target.value;
                });

                // Checkboxes
                document.getElementById('showVectors').addEventListener('change', (e) => {
                    this.settings.showVectors = e.target.checked;
                });

                // Select
                document.getElementById('flowPattern').addEventListener('change', (e) => {
                    this.settings.flowPattern = e.target.value;
                    this.generateVectorField();
                });

                // Mouse interaction
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));
            }

            handleImageUpload(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            this.uploadedImage = img;
                            const preview = document.getElementById('imagePreview');
                            preview.src = event.target.result;
                            preview.style.display = 'block';
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create local disturbance
                this.particles.forEach(particle => {
                    const dx = particle.x - x;
                    const dy = particle.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 100) {
                        const force = (100 - distance) / 100;
                        particle.vx += (dx / distance) * force * 0.1;
                        particle.vy += (dy / distance) * force * 0.1;
                    }
                });
            }

            handleMouseClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Create explosion effect
                for (let i = 0; i < 50; i++) {
                    const angle = (Math.PI * 2 * i) / 50;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        maxLife: 60
                    });
                }
            }

            initializeParticles() {
                this.particles = [];
                for (let i = 0; i < this.settings.particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        vx: 0,
                        vy: 0,
                        life: 1,
                        maxLife: this.settings.trailLength * 10,
                        trail: []
                    });
                }
            }

            generateVectorField() {
                this.vectors = [];
                const spacing = this.width / this.settings.vectorDensity;
                
                for (let x = spacing; x < this.width; x += spacing) {
                    for (let y = spacing; y < this.height; y += spacing) {
                        const vector = this.calculateFlowVector(x, y);
                        this.vectors.push({
                            x: x,
                            y: y,
                            vx: vector.vx,
                            vy: vector.vy
                        });
                    }
                }
            }

            calculateFlowVector(x, y) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                let vx = 0, vy = 0;
                const strength = this.settings.flowStrength / 100;
                const turbulence = this.settings.turbulence / 100;
                const direction = (this.settings.flowDirection * Math.PI) / 180;
                
                switch (this.settings.flowPattern) {
                    case 'uniform':
                        vx = Math.cos(direction) * strength;
                        vy = Math.sin(direction) * strength;
                        break;
                    
                    case 'vortex':
                        vx = -Math.sin(angle) * strength * (1 - distance / Math.max(this.width, this.height));
                        vy = Math.cos(angle) * strength * (1 - distance / Math.max(this.width, this.height));
                        break;
                    
                    case 'radial':
                        vx = (dx / distance) * strength;
                        vy = (dy / distance) * strength;
                        break;
                    
                    case 'spiral':
                        const spiralAngle = angle + this.time * 0.01;
                        vx = Math.cos(spiralAngle) * strength;
                        vy = Math.sin(spiralAngle) * strength;
                        break;
                    
                    case 'wave':
                        vx = Math.sin(y * 0.01 + this.time * 0.02) * strength;
                        vy = Math.cos(x * 0.01 + this.time * 0.02) * strength;
                        break;
                    
                    case 'turbulent':
                        vx = (Math.sin(x * 0.01 + this.time * 0.01) + Math.cos(y * 0.01)) * strength;
                        vy = (Math.cos(x * 0.01 + this.time * 0.01) + Math.sin(y * 0.01)) * strength;
                        break;
                }
                
                // Add turbulence
                vx += (Math.random() - 0.5) * turbulence;
                vy += (Math.random() - 0.5) * turbulence;
                
                return { vx, vy };
            }

            updateParticles() {
                this.particles.forEach((particle, index) => {
                    // Update trail
                    particle.trail.push({ x: particle.x, y: particle.y, life: particle.life });
                    if (particle.trail.length > this.settings.trailLength) {
                        particle.trail.shift();
                    }
                    
                    // Calculate flow influence
                    const flow = this.calculateFlowVector(particle.x, particle.y);
                    const speed = this.settings.particleSpeed / 100;
                    
                    // Apply flow
                    particle.vx += flow.vx * speed;
                    particle.vy += flow.vy * speed;
                    
                    // Apply viscosity
                    const viscosity = 1 - (this.settings.viscosity / 200);
                    particle.vx *= viscosity;
                    particle.vy *= viscosity;
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Boundary conditions
                    if (particle.x < 0) particle.x = this.width;
                    if (particle.x > this.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.height;
                    if (particle.y > this.height) particle.y = 0;
                    
                    // Update life
                    particle.life -= 1 / particle.maxLife;
                    if (particle.life <= 0) {
                        particle.x = Math.random() * this.width;
                        particle.y = Math.random() * this.height;
                        particle.vx = 0;
                        particle.vy = 0;
                        particle.life = 1;
                        particle.trail = [];
                    }
                });
            }

            render() {
                // Clear canvas with fade effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw background image if uploaded
                if (this.uploadedImage) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.settings.imageOpacity / 100;
                    
                    const scale = this.settings.imageScale / 100;
                    const imgWidth = this.uploadedImage.width * scale;
                    const imgHeight = this.uploadedImage.height * scale;
                    const x = (this.width - imgWidth) / 2;
                    const y = (this.height - imgHeight) / 2;
                    
                    this.ctx.drawImage(this.uploadedImage, x, y, imgWidth, imgHeight);
                    this.ctx.restore();
                }
                
                // Draw vector field
                if (this.settings.showVectors) {
                    this.ctx.strokeStyle = this.settings.vectorColor;
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.3;
                    
                    this.vectors.forEach(vector => {
                        const scale = this.settings.vectorScale;
                        this.ctx.beginPath();
                        this.ctx.moveTo(vector.x, vector.y);
                        this.ctx.lineTo(
                            vector.x + vector.vx * scale,
                            vector.y + vector.vy * scale
                        );
                        this.ctx.stroke();
                        
                        // Arrow head
                        const angle = Math.atan2(vector.vy, vector.vx);
                        const headLength = 5;
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            vector.x + vector.vx * scale,
                            vector.y + vector.vy * scale
                        );
                        this.ctx.lineTo(
                            vector.x + vector.vx * scale - headLength * Math.cos(angle - Math.PI / 6),
                            vector.y + vector.vy * scale - headLength * Math.sin(angle - Math.PI / 6)
                        );
                        this.ctx.lineTo(
                            vector.x + vector.vx * scale - headLength * Math.cos(angle + Math.PI / 6),
                            vector.y + vector.vy * scale - headLength * Math.sin(angle + Math.PI / 6)
                        );
                        this.ctx.stroke();
                    });
                }
                
                // Draw particles and trails
                this.ctx.globalAlpha = 1;
                this.particles.forEach(particle => {
                    // Draw trail
                    particle.trail.forEach((point, index) => {
                        const alpha = (index / particle.trail.length) * particle.life * 0.5;
                        this.ctx.fillStyle = this.hexToRgba(this.settings.particleColor, alpha);
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, this.settings.particleSize * 0.5, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                    
                    // Draw particle
                    this.ctx.fillStyle = this.hexToRgba(this.settings.particleColor, particle.life);
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, this.settings.particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            updateSimulation() {
                if (this.particles.length !== this.settings.particleCount) {
                    this.initializeParticles();
                }
                this.generateVectorField();
            }

            animate() {
                if (this.isAnimating) {
                    const currentTime = performance.now();
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.fps = Math.round(1000 / deltaTime);
                    this.lastFrameTime = currentTime;
                    
                    this.time += this.settings.animationSpeed / 1000;
                    
                    this.updateParticles();
                    this.render();
                    this.updateStats();
                }
                
                requestAnimationFrame(() => this.animate());
            }

            updateStats() {
                document.getElementById('fpsCounter').textContent = this.fps;
                document.getElementById('particleCounter').textContent = this.particles.length;
                
                // Calculate average flow rate
                let totalSpeed = 0;
                this.particles.forEach(particle => {
                    totalSpeed += Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                });
                const avgSpeed = totalSpeed / this.particles.length;
                document.getElementById('flowRate').textContent = (avgSpeed * 10).toFixed(1);
            }
        }

        // Global functions
        function toggleAnimation() {
            visualizer.isAnimating = !visualizer.isAnimating;
        }

        function resetSimulation() {
            visualizer.time = 0;
            visualizer.initializeParticles();
            visualizer.generateVectorField();
        }

        function exportFrame() {
            const link = document.createElement('a');
            link.download = 'airflow-visualization.png';
            link.href = visualizer.canvas.toDataURL();
            link.click();
        }

        function loadPreset(preset) {
            const presets = {
                wind: {
                    flowStrength: 70,
                    turbulence: 10,
                    viscosity: 5,
                    flowDirection: 0,
                    particleSpeed: 20,
                    flowPattern: 'uniform'
                },
                hurricane: {
                    flowStrength: 90,
                    turbulence: 60,
                    viscosity: 30,
                    flowDirection: 0,
                    particleSpeed: 30,
                    flowPattern: 'vortex'
                },
                laminar: {
                    flowStrength: 40,
                    turbulence: 5,
                    viscosity: 80,
                    flowDirection: 90,
                    particleSpeed: 15,
                    flowPattern: 'uniform'
                },
                chaos: {
                    flowStrength: 100,
                    turbulence: 95,
                    viscosity: 10,
                    flowDirection: 0,
                    particleSpeed: 40,
                    flowPattern: 'turbulent'
                },
                gentle: {
                    flowStrength: 20,
                    turbulence: 15,
                    viscosity: 60,
                    flowDirection: 45,
                    particleSpeed: 8,
                    flowPattern: 'wave'
                },
                industrial: {
                    flowStrength: 80,
                    turbulence: 25,
                    viscosity: 15,
                    flowDirection: 0,
                    particleSpeed: 25,
                    flowPattern: 'radial'
                }
            };

            const config = presets[preset];
            if (config) {
                Object.keys(config).forEach(key => {
                    visualizer.settings[key] = config[key];
                    const slider = document.getElementById(key);
                    const display = document.getElementById(key + 'Value');
                    if (slider && display) {
                        slider.value = config[key];
                        display.textContent = key === 'flowDirection' ? config[key] + '¬∞' : config[key];
                    }
                });

                // Update flow pattern select
                document.getElementById('flowPattern').value = config.flowPattern;
                visualizer.updateSimulation();
            }
        }

        // Advanced Features Class
        class AdvancedFeatures {
            constructor(visualizer) {
                this.visualizer = visualizer;
                this.obstacles = [];
                this.sources = [];
                this.sinks = [];
                this.pressureField = [];
                this.heatMap = false;
                this.streamlines = [];
                this.recording = false;
                this.recordedFrames = [];
            }

            addObstacle(x, y, radius, type = 'circle') {
                this.obstacles.push({
                    x, y, radius, type,
                    id: Date.now() + Math.random()
                });
                this.updateFlowField();
            }

            addSource(x, y, strength = 1) {
                this.sources.push({
                    x, y, strength,
                    id: Date.now() + Math.random()
                });
            }

            addSink(x, y, strength = 1) {
                this.sinks.push({
                    x, y, strength,
                    id: Date.now() + Math.random()
                });
            }

            calculatePressureField() {
                const resolution = 20;
                this.pressureField = [];
                
                for (let x = 0; x < this.visualizer.width; x += resolution) {
                    for (let y = 0; y < this.visualizer.height; y += resolution) {
                        let pressure = 0;
                        
                        // Calculate pressure from obstacles
                        this.obstacles.forEach(obstacle => {
                            const dx = x - obstacle.x;
                            const dy = y - obstacle.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < obstacle.radius * 2) {
                                pressure += (obstacle.radius * 2 - distance) / (obstacle.radius * 2);
                            }
                        });

                        // Calculate pressure from sources and sinks
                        this.sources.forEach(source => {
                            const dx = x - source.x;
                            const dy = y - source.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            pressure += source.strength / (distance + 1);
                        });

                        this.sinks.forEach(sink => {
                            const dx = x - sink.x;
                            const dy = y - sink.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            pressure -= sink.strength / (distance + 1);
                        });

                        this.pressureField.push({ x, y, pressure });
                    }
                }
            }

            generateStreamlines() {
                this.streamlines = [];
                const numLines = 20;
                
                for (let i = 0; i < numLines; i++) {
                    const startX = (this.visualizer.width / numLines) * i;
                    const startY = Math.random() * this.visualizer.height;
                    const streamline = this.traceStreamline(startX, startY);
                    this.streamlines.push(streamline);
                }
            }

            traceStreamline(startX, startY) {
                const points = [];
                let x = startX;
                let y = startY;
                const maxPoints = 200;
                const stepSize = 2;

                for (let i = 0; i < maxPoints; i++) {
                    points.push({ x, y });
                    
                    const flow = this.visualizer.calculateFlowVector(x, y);
                    const magnitude = Math.sqrt(flow.vx * flow.vx + flow.vy * flow.vy);
                    
                    if (magnitude < 0.01) break;
                    
                    x += (flow.vx / magnitude) * stepSize;
                    y += (flow.vy / magnitude) * stepSize;
                    
                    if (x < 0 || x > this.visualizer.width || y < 0 || y > this.visualizer.height) {
                        break;
                    }
                }

                return points;
            }

            updateFlowField() {
                // Recalculate flow field considering obstacles
                this.visualizer.generateVectorField();
                this.calculatePressureField();
                this.generateStreamlines();
            }

            renderAdvanced(ctx) {
                // Render pressure field as heat map
                if (this.heatMap) {
                    this.renderHeatMap(ctx);
                }

                // Render streamlines
                this.renderStreamlines(ctx);

                // Render obstacles
                this.renderObstacles(ctx);

                // Render sources and sinks
                this.renderSourcesSinks(ctx);
            }

            renderHeatMap(ctx) {
                this.pressureField.forEach(point => {
                    const intensity = Math.min(Math.abs(point.pressure), 1);
                    const color = point.pressure > 0 ? 
                        `rgba(255, 0, 0, ${intensity * 0.3})` : 
                        `rgba(0, 0, 255, ${intensity * 0.3})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(point.x - 10, point.y - 10, 20, 20);
                });
            }

            renderStreamlines(ctx) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                
                this.streamlines.forEach(streamline => {
                    if (streamline.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(streamline[0].x, streamline[0].y);
                        streamline.forEach(point => {
                            ctx.lineTo(point.x, point.y);
                        });
                        ctx.stroke();
                    }
                });
            }

            renderObstacles(ctx) {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                ctx.strokeStyle = 'rgba(150, 150, 150, 1)';
                ctx.lineWidth = 2;
                
                this.obstacles.forEach(obstacle => {
                    ctx.beginPath();
                    if (obstacle.type === 'circle') {
                        ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    } else if (obstacle.type === 'square') {
                        ctx.rect(
                            obstacle.x - obstacle.radius,
                            obstacle.y - obstacle.radius,
                            obstacle.radius * 2,
                            obstacle.radius * 2
                        );
                    }
                    ctx.fill();
                    ctx.stroke();
                });
            }

            renderSourcesSinks(ctx) {
                // Render sources
                ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
                this.sources.forEach(source => {
                    ctx.beginPath();
                    ctx.arc(source.x, source.y, 10 * source.strength, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw plus sign
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(source.x - 5, source.y);
                    ctx.lineTo(source.x + 5, source.y);
                    ctx.moveTo(source.x, source.y - 5);
                    ctx.lineTo(source.x, source.y + 5);
                    ctx.stroke();
                });

                // Render sinks
                ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                this.sinks.forEach(sink => {
                    ctx.beginPath();
                    ctx.arc(sink.x, sink.y, 10 * sink.strength, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw minus sign
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(sink.x - 5, sink.y);
                    ctx.lineTo(sink.x + 5, sink.y);
                    ctx.stroke();
                });
            }

            startRecording() {
                this.recording = true;
                this.recordedFrames = [];
            }

            stopRecording() {
                this.recording = false;
                return this.recordedFrames;
            }

            recordFrame() {
                if (this.recording) {
                    this.recordedFrames.push(this.visualizer.canvas.toDataURL());
                }
            }
        }

        // Initialize the visualizer
        let visualizer;
        let advancedFeatures;

        window.addEventListener('DOMContentLoaded', () => {
            visualizer = new AirflowVisualizer();
            advancedFeatures = new AdvancedFeatures(visualizer);

            // Override the render method to include advanced features
            const originalRender = visualizer.render.bind(visualizer);
            visualizer.render = function() {
                originalRender();
                advancedFeatures.renderAdvanced(this.ctx);
                advancedFeatures.recordFrame();
            };

            // Add advanced interaction handlers
            let currentTool = 'particle';
            let isDrawing = false;

            visualizer.canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const rect = visualizer.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                switch(currentTool) {
                    case 'obstacle':
                        advancedFeatures.addObstacle(x, y, 20);
                        break;
                    case 'source':
                        advancedFeatures.addSource(x, y, 1);
                        break;
                    case 'sink':
                        advancedFeatures.addSink(x, y, 1);
                        break;
                }
            });

            visualizer.canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        toggleAnimation();
                        break;
                    case 'r':
                        resetSimulation();
                        break;
                    case 'h':
                        advancedFeatures.heatMap = !advancedFeatures.heatMap;
                        advancedFeatures.calculatePressureField();
                        break;
                    case 's':
                        advancedFeatures.generateStreamlines();
                        break;
                    case '1':
                        currentTool = 'particle';
                        break;
                    case '2':
                        currentTool = 'obstacle';
                        break;
                    case '3':
                        currentTool = 'source';
                        break;
                    case '4':
                        currentTool = 'sink';
                        break;
                }
            });

            // Performance monitoring
            setInterval(() => {
                const memoryInfo = performance.memory;
                if (memoryInfo) {
                    console.log('Memory usage:', {
                        used: Math.round(memoryInfo.usedJSHeapSize / 1048576) + 'MB',
                        total: Math.round(memoryInfo.totalJSHeapSize / 1048576) + 'MB',
                        limit: Math.round(memoryInfo.jsHeapSizeLimit / 1048576) + 'MB'
                    });
                }
            }, 5000);

            console.log('üå™Ô∏è Advanced Airflow Visualizer Loaded');
            console.log('Keyboard shortcuts:');
            console.log('- Space: Play/Pause');
            console.log('- R: Reset simulation');
            console.log('- H: Toggle heat map');
            console.log('- S: Generate streamlines');
            console.log('- 1: Particle tool');
            console.log('- 2: Obstacle tool');
            console.log('- 3: Source tool');
            console.log('- 4: Sink tool');
        });

        // Export functions for GitHub integration
        window.AirflowVisualizer = {
            export: () => {
                return {
                    settings: visualizer.settings,
                    obstacles: advancedFeatures.obstacles,
                    sources: advancedFeatures.sources,
                    sinks: advancedFeatures.sinks
                };
            },
            import: (data) => {
                if (data.settings) {
                    Object.assign(visualizer.settings, data.settings);
                    visualizer.updateSimulation();
                }
                if (data.obstacles) {
                    advancedFeatures.obstacles = data.obstacles;
                }
                if (data.sources) {
                    advancedFeatures.sources = data.sources;
                }
                if (data.sinks) {
                    advancedFeatures.sinks = data.sinks;
                }
                advancedFeatures.updateFlowField();
            },
            startRecording: () => advancedFeatures.startRecording(),
            stopRecording: () => advancedFeatures.stopRecording(),
            version: '2.0.0'
        };
    </script>
</body>
</html>
